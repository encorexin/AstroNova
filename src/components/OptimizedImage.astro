---

import { Image } from 'astro:assets';
import { imageConfig } from '@/config/performance';

export interface Props {
  src: string;
  alt: string;
  width?: number | undefined;
  height?: number | undefined;
  class?: string | null | undefined;
  loading?: 'lazy' | 'eager' | undefined;
  sizes?: string | null | undefined;
  quality?: number | undefined;
  format?: 'avif' | 'webp' | 'jpg' | undefined;
  priority?: boolean | undefined;
}

const {
  src: _src,
  alt: _alt,
  width: _width,
  height: _height,
  class: _className = '',
  loading: _loading = imageConfig.loading,
  sizes: _sizes = '100vw',
  quality: _quality = imageConfig.quality,
  priority: _priority = false,
} = Astro.props;

// Calculate image ratio for placeholder
const _aspectRatio = _width && _height ? (_height / _width) * 100 : 56.25; // Default 16:9

// Responsive breakpoints
const breakpoints = [640, 768, 1024, 1280, 1920];
---

<div
  class="relative overflow-hidden bg-gray-100 dark:bg-gray-800"
  style={`padding-bottom: ${_aspectRatio}%`}
>
  <picture class="absolute inset-0">
    {
      _width && _height ? (
        <>
          <source
            srcset={`${_src}?format=avif&width=${breakpoints.map(bp => `${_src}?format=avif&width=${bp} ${bp}w`).join(', ')}`}
            type="image/avif"
            sizes={_sizes}
            media="(min-width: 640px)"
          />
          <source
            srcset={`${_src}?format=webp&width=${breakpoints.map(bp => `${_src}?format=webp&width=${bp} ${bp}w`).join(', ')}`}
            type="image/webp"
            sizes={_sizes}
            media="(min-width: 640px)"
          />
          <Image
            src={_src}
            alt={_alt}
            width={_width}
            height={_height}
            loading={_priority ? 'eager' : _loading as 'lazy' | 'eager'}
            decoding={_priority ? 'sync' : 'async'}
            class={`absolute inset-0 h-full w-full object-cover transition-opacity duration-300 ${_className}`}
            quality={_quality}
            sizes={_sizes}
            fetchpriority={_priority ? 'high' : 'auto'}
          />
        </>
      ) : (
        <Image
          src={_src}
          alt={_alt}
          loading={_priority ? 'eager' : _loading as 'lazy' | 'eager'}
          decoding={_priority ? 'sync' : 'async'}
          class={`absolute inset-0 h-full w-full object-cover transition-opacity duration-300 ${_className}`}
          quality={_quality}
          sizes={_sizes}
          inferSize
          fetchpriority={_priority ? 'high' : 'auto'}
        />
      )
    }
  </picture>

  <!-- Enhanced loading placeholder with blur effect -->
  <div
    class="absolute inset-0 animate-pulse bg-gradient-to-br from-gray-200 via-gray-300 to-gray-200 dark:from-gray-700 dark:via-gray-600 dark:to-gray-700"
    aria-hidden="true"
    style="background-size: 200% 200%; animation: shimmer 2s ease-in-out infinite;"
  >
    <div class="absolute inset-0 flex items-center justify-center">
      <div class="relative">
        <div class="h-12 w-12 rounded-full bg-gray-400/20 dark:bg-gray-500/20 animate-ping"></div>
        <svg
          class="absolute inset-0 h-12 w-12 text-gray-400 dark:text-gray-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
          ></path>
        </svg>
      </div>
    </div>
  </div>
</div>

<style>
  /* Image fade-in animation */
  img {
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    will-change: opacity;
  }

  img[data-loaded] {
    opacity: 1;
  }

  /* Enhanced placeholder animations */
  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  @keyframes shimmer {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  .animate-shimmer {
    animation: shimmer 2s ease-in-out infinite;
  }

  /* Responsive image container */
  picture {
    display: contents;
  }
</style>

<script>
  // Enhanced image loading with Intersection Observer
  const imageObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target as HTMLImageElement;
          img.setAttribute('data-loaded', 'true');
          imageObserver.unobserve(img);
        }
      });
    },
    {
      rootMargin: '50px',
      threshold: 0.01,
    }
  );

  // Initialize image loading
  function initializeImages() {
    const images = document.querySelectorAll('img[data-lazy]');
    
    images.forEach((img) => {
      if (img instanceof HTMLImageElement && img.complete) {
        img.setAttribute('data-loaded', 'true');
      } else {
        img.addEventListener('load', () => {
          img.setAttribute('data-loaded', 'true');
        });
        
        // Fallback for browsers without Intersection Observer
        if (!('IntersectionObserver' in window)) {
          img.setAttribute('data-loaded', 'true');
        } else {
          imageObserver.observe(img);
        }
      }
    });
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeImages);
  } else {
    initializeImages();
  }

  // Cleanup observer on page unload
  window.addEventListener('beforeunload', () => {
    imageObserver.disconnect();
  });
</script>
