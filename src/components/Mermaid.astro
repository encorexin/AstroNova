---
/**
 * Mermaid Diagram Component
 * Renders Mermaid diagrams from code blocks in Markdown
 * 
 * Usage in Markdown:
 * ```mermaid
 * graph TD
 *   A[Start] --> B{Decision}
 *   B -->|Yes| C[OK]
 *   B -->|No| D[Cancel]
 * ```
 */
export interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`mermaid-container ${className}`} data-mermaid-container>
  <!-- Mermaid diagrams will be rendered here -->
</div>

<script>
  import mermaid from 'mermaid';

  // Initialize Mermaid with custom config
  mermaid.initialize({
    startOnLoad: false,
    theme: 'default',
    securityLevel: 'loose',
    fontFamily: 'Inter, system-ui, sans-serif',
    flowchart: {
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'basis',
    },
    sequence: {
      useMaxWidth: true,
      diagramMarginX: 50,
      diagramMarginY: 10,
      actorMargin: 50,
      boxMargin: 10,
    },
    themeVariables: {
      primaryColor: '#3b82f6',
      primaryTextColor: '#1e293b',
      primaryBorderColor: '#60a5fa',
      lineColor: '#64748b',
      secondaryColor: '#e2e8f0',
      tertiaryColor: '#f1f5f9',
    },
  });

  // Function to update theme
  function updateMermaidTheme(isDark: boolean) {
    mermaid.initialize({
      startOnLoad: false,
      theme: isDark ? 'dark' : 'default',
      securityLevel: 'loose',
      fontFamily: 'Inter, system-ui, sans-serif',
      themeVariables: isDark ? {
        primaryColor: '#3b82f6',
        primaryTextColor: '#e2e8f0',
        primaryBorderColor: '#60a5fa',
        lineColor: '#94a3b8',
        secondaryColor: '#334155',
        tertiaryColor: '#1e293b',
        background: '#0f172a',
        mainBkg: '#1e293b',
        nodeBorder: '#60a5fa',
      } : {
        primaryColor: '#3b82f6',
        primaryTextColor: '#1e293b',
        primaryBorderColor: '#60a5fa',
        lineColor: '#64748b',
        secondaryColor: '#e2e8f0',
        tertiaryColor: '#f1f5f9',
      },
    });
  }

  // Render all mermaid code blocks
  async function renderMermaidDiagrams() {
    const isDark = document.documentElement.classList.contains('dark');
    updateMermaidTheme(isDark);

    // Find all mermaid code blocks with various selectors
    // Shiki uses data-language attribute, others might use class
    const mermaidBlocks: Element[] = [];
    
    // Shiki-style: pre with data-language="mermaid"
    document.querySelectorAll('pre[data-language="mermaid"]').forEach(el => mermaidBlocks.push(el));
    
    // Class-based: code.language-mermaid or pre.language-mermaid
    document.querySelectorAll('pre > code.language-mermaid, pre.language-mermaid').forEach(el => mermaidBlocks.push(el));
    
    // Also check for spans with mermaid content from Shiki
    document.querySelectorAll('pre.astro-code').forEach(pre => {
      const codeEl = pre.querySelector('code');
      if (codeEl) {
        const text = codeEl.textContent || '';
        // Check if content looks like mermaid (starts with common mermaid keywords)
        const mermaidKeywords = ['graph ', 'flowchart ', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'erDiagram', 'gitGraph', 'pie ', 'journey', 'gantt'];
        const trimmedText = text.trim();
        if (mermaidKeywords.some(kw => trimmedText.startsWith(kw))) {
          mermaidBlocks.push(pre);
        }
      }
    });
    
    for (let i = 0; i < mermaidBlocks.length; i++) {
      const block = mermaidBlocks[i];
      if (!block) continue;
      
      // Get the pre element
      const pre = block.tagName === 'PRE' ? block : block.closest('pre') || block.parentElement;
      if (!pre || pre.hasAttribute('data-mermaid-processed')) continue;
      
      // Mark as processed to avoid double-processing
      pre.setAttribute('data-mermaid-processed', 'true');
      
      // Extract code content - handle Shiki's span-based structure
      let code = '';
      const codeEl = pre.querySelector('code');
      if (codeEl) {
        // Get text content from all spans or direct text
        code = codeEl.textContent || '';
      } else {
        code = block.textContent || '';
      }
      
      if (!code.trim()) continue;

      try {
        // Create container for the diagram
        const container = document.createElement('div');
        container.className = 'mermaid-diagram not-prose my-6 flex justify-center overflow-x-auto rounded-lg border bg-card p-4';
        
        // Generate unique ID
        const id = `mermaid-${Date.now()}-${i}`;
        
        // Render the diagram
        const { svg } = await mermaid.render(id, code.trim());
        container.innerHTML = svg;
        
        // Replace the code block with the rendered diagram
        pre.parentElement?.replaceChild(container, pre);
      } catch (error) {
        console.error('Mermaid rendering error:', error);
        // Keep the original code block but add error styling
        pre.classList.add('mermaid-error');
        const errorMsg = document.createElement('div');
        errorMsg.className = 'text-sm text-destructive mt-2';
        errorMsg.textContent = 'Failed to render diagram: ' + (error instanceof Error ? error.message : 'Unknown error');
        pre.parentElement?.insertBefore(errorMsg, pre.nextSibling);
      }
    }
  }

  // Initial render
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', renderMermaidDiagrams);
  } else {
    renderMermaidDiagrams();
  }

  // Re-render on theme change
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        // Theme changed, re-render diagrams
        const diagrams = document.querySelectorAll('.mermaid-diagram');
        if (diagrams.length > 0) {
          // Remove processed diagrams and re-render
          location.reload(); // Simple approach for theme change
        }
      }
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class'],
  });
</script>

<style>
  .mermaid-diagram {
    min-height: 100px;
  }

  .mermaid-diagram svg {
    max-width: 100%;
    height: auto;
  }

  .mermaid-error {
    border-color: hsl(var(--destructive)) !important;
  }

  /* Dark mode adjustments */
  :global(.dark) .mermaid-diagram {
    background-color: hsl(var(--card));
  }

  :global(.dark) .mermaid-diagram svg {
    filter: none;
  }
</style>
