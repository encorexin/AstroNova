---
/**
 * Table of Contents Component
 * Renders a navigable table of contents from markdown headings
 */
export interface Props {
  headings: { depth: number; slug: string; text: string }[];
  class?: string;
}

const { headings, class: className = '' } = Astro.props;

// Filter to only include h2 and h3 headings
const filteredHeadings = headings.filter((h) => h.depth >= 2 && h.depth <= 3);
---

{
  filteredHeadings.length > 0 && (
    <nav
      class={`toc rounded-lg border bg-card p-4 ${className}`}
      aria-label="Table of Contents"
    >
      <h2 class="mb-4 text-lg font-semibold">Table of Contents</h2>
      <ul class="space-y-2 text-sm" data-toc-list>
        {filteredHeadings.map((heading) => (
          <li
            class={`toc-item ${heading.depth === 3 ? 'ml-4' : ''}`}
            data-depth={heading.depth}
          >
            <a
              href={`#${heading.slug}`}
              class="block rounded-md px-2 py-1 text-muted-foreground transition-colors hover:bg-muted hover:text-foreground"
              data-toc-link
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ul>
    </nav>
  )
}

<style>
  .toc-item a.active {
    @apply bg-primary/10 text-primary font-medium;
  }
</style>

<script>
  class TableOfContents {
    private links: NodeListOf<HTMLAnchorElement>;
    private headings: HTMLElement[] = [];
    private observer: IntersectionObserver | null = null;

    constructor() {
      this.links = document.querySelectorAll('[data-toc-link]');
      this.init();
    }

    private init() {
      // Get all heading elements referenced by TOC links
      this.links.forEach((link) => {
        const id = link.getAttribute('href')?.replace('#', '');
        if (id) {
          const heading = document.getElementById(id);
          if (heading) {
            this.headings.push(heading);
          }
        }
      });

      // Set up Intersection Observer
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              this.setActiveLink(entry.target.id);
            }
          });
        },
        {
          rootMargin: '-80px 0px -80% 0px',
          threshold: 0,
        }
      );

      // Observe all headings
      this.headings.forEach((heading) => {
        this.observer?.observe(heading);
      });

      // Add smooth scroll behavior
      this.links.forEach((link) => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const id = link.getAttribute('href')?.replace('#', '');
          if (id) {
            const target = document.getElementById(id);
            if (target) {
              const offset = 100; // Account for sticky header
              const top = target.getBoundingClientRect().top + window.scrollY - offset;
              window.scrollTo({ top, behavior: 'smooth' });
              history.pushState(null, '', `#${id}`);
            }
          }
        });
      });
    }

    private setActiveLink(id: string) {
      this.links.forEach((link) => {
        const linkId = link.getAttribute('href')?.replace('#', '');
        if (linkId === id) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
      });
    }
  }

  // Initialize when DOM is ready
  if (document.querySelector('[data-toc-list]')) {
    new TableOfContents();
  }
</script>
